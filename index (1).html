<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Secure PassPhrase Generator</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Roboto:wght@300;400&display=swap');

    body {
      margin: 0;
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(135deg, #0a0a0a, #1a1a3a);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow-x: hidden;
      position: relative;
    }

    .container {
      background: rgba(10, 10, 20, 0.85);
      border-radius: 16px;
      padding: 2rem;
      box-shadow: 0 0 20px rgba(0, 240, 255, 0.3);
      border: 1px solid #00f0ff;
      max-width: 600px;
      width: 90%;
      text-align: center;
      position: relative;
      animation: glitch 1s ease-out;
    }

    @keyframes glitch {
      0% { transform: translate(0); opacity: 1; }
      2% { transform: translate(2px, -2px); opacity: 0.8; }
      4% { transform: translate(-2px, 2px); opacity: 0.9; }
      6% { transform: translate(0); opacity: 1; }
    }

    h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 2.2rem;
      font-weight: 700;
      color: #ffff00;
      text-shadow: 0 0 10px #ffff00;
      margin-bottom: 1rem;
      letter-spacing: 1px;
    }

    #passphrase {
      font-family: 'Roboto', sans-serif;
      font-size: 1.5rem;
      font-weight: 400;
      color: #fff;
      background: rgba(0, 0, 0, 0.5);
      padding: 1rem;
      border-radius: 12px;
      margin: 1.5rem 0;
      word-break: break-word;
      border: 1px solid #d400ff;
      transition: all 0.3s ease;
      animation: pulseNeon 2s infinite;
    }

    #passphrase:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 15px rgba(212, 0, 255, 0.5);
    }

    @keyframes pulseNeon {
      0% { box-shadow: 0 0 5px rgba(212, 0, 255, 0.5); }
      50% { box-shadow: 0 0 15px rgba(212, 0, 255, 0.8); }
      100% { box-shadow: 0 0 5px rgba(212, 0, 255, 0.5); }
    }

    select, button {
      font-family: 'Roboto', sans-serif;
      font-size: 0.9rem;
      font-weight: 400;
      padding: 0.5rem 1.5rem;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 0 10px rgba(0, 240, 255, 0.3);
    }

    select {
      background: #1a1a3a;
      color: #ffffff;
      margin-right: 1rem;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      padding-right: 2.5rem;
      background-image: url("data:image/svg+xml;utf8,<svg fill='%2300f0ff' height='24' viewBox='0 0 24 24' width='24' xmlns='http://www.w3.org/2000/svg'><path d='M7 10l5 5 5-5z'/><path d='M0 0h24v24H0z' fill='none'/></svg>");
      background-repeat: no-repeat;
      background-position: right 0.5rem top 50%;
    }

    select:hover {
      background-color: #2a2a5a;
      border: 1px solid #00f0ff;
      box-shadow: 0 0 15px rgba(212, 0, 255, 0.5);
    }

    select option {
      background: #1a1a3a;
      color: #ffffff;
    }

    button {
      background: linear-gradient(45deg, #00f0ff, #d400ff);
      color: #fff;
      font-weight: 400;
    }

    button:hover {
      background: linear-gradient(45deg, #d400ff, #00f0ff);
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(212, 0, 255, 0.5);
    }

    input[type="checkbox"] {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: #333;
      border-radius: 4px;
      cursor: pointer;
      position: relative;
      box-shadow: 0 0 5px rgba(0, 240, 255, 0.3);
    }

    input[type="checkbox"]:checked {
      background: #00f0ff;
      box-shadow: 0 0 10px #00f0ff;
    }

    input[type="checkbox"]:checked::after {
      content: '✔';
      color: #1a1a3a;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
    }

    input[type="checkbox"]:hover {
      box-shadow: 0 0 10px #d400ff;
    }

    #entropy {
      font-family: 'Roboto', sans-serif;
      font-size: 0.9rem;
      font-weight: 300;
      color: #b0b0ff;
      margin-top: 1rem;
      text-shadow: 0 0 5px #b0b0ff;
    }

    label {
      font-family: 'Roboto', sans-serif;
      color: #00f0ff;
      font-size: 1rem;
      font-weight: 400;
      margin-right: 0.5rem;
    }

    .strength-meter, .mfa-security-meter {
      margin: 1rem 0;
      height: 8px;
      background: #333;
      border-radius: 4px;
      overflow: hidden;
      position: relative;
      box-shadow: 0 0 5px rgba(0, 240, 255, 0.3);
    }

    .strength-bar, .mfa-security-bar {
      height: 100%;
      transition: width 0.5s ease, background 0.5s ease;
      box-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
    }

    .strength-text, .mfa-security-text {
      font-family: 'Roboto', sans-serif;
      font-size: 0.9rem;
      font-weight: 300;
      color: #b0b0ff;
      margin-top: 0.5rem;
      margin-bottom: 1.5rem;
      text-shadow: 0 0 5px #b0b0ff;
    }

    #charCount {
      font-family: 'Roboto', sans-serif;
      font-size: 0.9rem;
      font-weight: 300;
      color: #b0b0ff;
      margin-top: 0.5rem;
      margin-bottom: 1.5rem;
      text-shadow: 0 0 5px #b0b0ff;
    }

    .dropdown-container {
      margin-bottom: 1rem;
    }

    #copyMessage {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 240, 255, 0.9);
      color: #1a1a3a;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      font-family: 'Roboto', sans-serif;
      font-size: 0.9rem;
      font-weight: 400;
      box-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
      z-index: 1000;
    }

    #copyMessage.show {
      opacity: 1;
    }

    @media (max-width: 600px) {
      h1 {
        font-size: 1.8rem;
      }
      #passphrase {
        font-size: 1.2rem;
      }
      select, button, input[type="checkbox"] {
        padding: 0.4rem 1rem;
        font-size: 0.85rem;
      }
      .container {
        padding: 1.5rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Secure PassPhrase Generator</h1>
    
    <div class="dropdown-container flex justify-center items-center mb-4">
      <label for="wordCount">Words:</label>
      <select id="wordCount">
        <option value="3" selected>3</option>
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10</option>
        <option value="11">11</option>
        <option value="12">12</option>
        <option value="13">13</option>
        <option value="14">14</option>
        <option value="15">15</option>
        <option value="16">16</option>
        <option value="17">17</option>
        <option value="18">18</option>
        <option value="19">19</option>
        <option value="20">20</option>
      </select>
    </div>

    <div class="dropdown-container flex justify-center items-center mb-4">
      <label for="specialCharCount">Special Characters:</label>
      <select id="specialCharCount">
        <option value="0">0</option>
        <option value="1" selected>1</option>
        <option value="2">2</option>
        <option value="3">3</option>
      </select>
    </div>

    <div class="dropdown-container flex justify-center items-center mb-4">
      <label for="leetCount">Leetspeak Numbers:</label>
      <select id="leetCount">
        <option value="0">0</option>
        <option value="1" selected>1</option>
        <option value="2">2</option>
        <option value="3">3</option>
      </select>
    </div>

    <div class="dropdown-container flex justify-center items-center mb-4">
      <label for="caseStyle">Case Style:</label>
      <select id="caseStyle">
        <option value="firstLetter" selected>First Letter Capitalized</option>
        <option value="allCapsExceptOne">All Caps Except One</option>
      </select>
    </div>

    <div class="dropdown-container flex justify-center items-center mb-4">
      <label for="addSpaces">Add Spaces Between Words:</label>
      <input type="checkbox" id="addSpaces">
    </div>

    <div id="passphrase">Click below to generate</div>
    <div class="strength-meter">
      <div id="strengthBar" class="strength-bar"></div>
    </div>
    <div id="strengthText" class="strength-text">Time to crack with RTX 5090: N/A</div>
    <div class="mfa-security-meter">
      <div id="mfaSecurityBar" class="mfa-security-bar"></div>
    </div>
    <div id="mfaSecurityText" class="mfa-security-text">Cracking Likelihood with MFA: N/A</div>
    <div id="charCount">Length: N/A</div>
    <div class="flex justify-center space-x-4">
      <button onclick="generatePassphrase()">Generate</button>
      <button onclick="copyToClipboard()">Copy</button>
    </div>
    <div id="entropy">Entropy: N/A</div>
    <div style="font-family: 'Roboto', sans-serif; font-size: 0.8rem; color: #b0b0ff; margin-top: 1rem; text-shadow: 0 0 5px #b0b0ff;">Created by K.R.</div>
    <div id="copyMessage"></div>
  </div>

  <script>
    const leetMap = {
      a: '4', e: '3', i: '1', s: '5', t: '7'
    };

    const specialChars = ['!', '@', '#'];
    const baseWords = [
      'the', 'quick', 'blue', 'fox', 'jumps',
      'over', 'gentle', 'dog', 'and', 'runs',
      'through', 'green', 'forest', 'with', 'bright',
      'sun', 'shines', 'on', 'calm', 'lake',
      'where', 'birds', 'sing', 'near', 'clear',
      'sky', 'while', 'wind', 'flow', 'softly'
    ];

    function toLeetspeak(word, leetApplied, allowLeet, wordIndex) {
      if (!allowLeet) return word;
      const leetableIndices = [];
      word.split('').forEach((char, index) => {
        if (leetMap[char.toLowerCase()]) leetableIndices.push(index);
      });
      if (leetableIndices.length === 0) return word;
      const chosenIndex = leetableIndices[Math.floor(Math.random() * leetableIndices.length)];
      const chars = word.split('');
      chars[chosenIndex] = leetMap[chars[chosenIndex].toLowerCase()];
      leetApplied.push({ wordIndex: wordIndex, charIndex: chosenIndex, char: chars[chosenIndex] });
      return chars.join('');
    }

    function applyCaseStyle(words, caseStyle, leetApplied, specialApplied, addSpaces) {
      const modifiedWords = words.map(word => {
        if (word.length > 0) {
          return caseStyle === 'firstLetter'
            ? word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
            : word.toUpperCase();
        }
        return word;
      });
      let result = modifiedWords[0];
      for (let i = 1; i < modifiedWords.length; i++) {
        const special = specialApplied.find(sa => sa.pos === i);
        const separator = addSpaces ? ' ' : '';
        result += (separator) + (special ? special.char : '') + modifiedWords[i];
      }
      const endSpecial = specialApplied.find(sa => sa.pos === modifiedWords.length);
      if (endSpecial) result += endSpecial.char;
      
      if (caseStyle === 'allCapsExceptOne') {
        let chars = result.split('');
        const eligibleIndices = [];
        let currentWordIndex = 0;
        let charIndexInWord = 0;
        for (let i = 0; i < result.length; i++) {
          const isSpecial = specialApplied.some(sa => sa.pos * 1000 + sa.char.charCodeAt(0) === i);
          const isSpace = addSpaces && result[i] === ' ';
          const isLeet = leetApplied.some(la => la.wordIndex === currentWordIndex && la.charIndex === charIndexInWord && /[0-9]/.test(result[i]));
          if (!isSpecial && !isSpace && /[a-zA-Z]/.test(result[i]) && !isLeet) {
            eligibleIndices.push(i);
          }
          if (!isSpecial && !isSpace) {
            charIndexInWord++;
          }
          if (isSpecial || isSpace || i === result.length - 1) {
            charIndexInWord = 0;
            currentWordIndex++;
          }
        }
        if (eligibleIndices.length > 0) {
          const lowercaseIndex = eligibleIndices[Math.floor(Math.random() * eligibleIndices.length)];
          chars[lowercaseIndex] = chars[lowercaseIndex].toLowerCase();
        } else if (chars.some(c => /[a-zA-Z]/.test(c))) {
          const letterIndices = chars.map((c, i) => /[a-zA-Z]/.test(c) ? i : -1).filter(i => i !== -1);
          const lowercaseIndex = letterIndices[Math.floor(Math.random() * letterIndices.length)];
          chars[lowercaseIndex] = chars[lowercaseIndex].toLowerCase();
        }
        result = chars.join('');
      }
      return result;
    }

    function calculateWordEntropy(word, isLeetWord, caseStyle, totalLetters) {
      const wordChoiceEntropy = Math.log2(baseWords.length); // 25 words
      const leetEntropy = isLeetWord ? Math.log2(2) : 0; // 1 bit if this word has leetspeak
      const capitalizationEntropy = caseStyle === 'firstLetter' ? Math.log2(2) : 0; // 1 bit per word for first letter capitalized
      return wordChoiceEntropy + leetEntropy + capitalizationEntropy;
    }

    function estimateEntropy(words, leetWordIndices, leetCharCount, specialCharCount, caseStyle, totalLetters, addSpaces) {
      let totalEntropy = 0;
      for (let i = 0; i < words.length; i++) {
        totalEntropy += calculateWordEntropy(words[i], leetWordIndices.includes(i), caseStyle, totalLetters);
      }
      if (leetCharCount > 0) {
        totalEntropy += Math.log2(leetCharCount) * leetWordIndices.length; // Entropy for choosing leetable chars
      }
      if (specialCharCount > 0) {
        totalEntropy += Math.log2(specialChars.length) * specialCharCount; // Entropy for special chars
        totalEntropy += Math.log2(words.length + 1) * specialCharCount; // Entropy for choosing positions
      }
      if (caseStyle === 'allCapsExceptOne' && totalLetters > 0) {
        totalEntropy += Math.log2(totalLetters); // Entropy for choosing which letter is lowercase
      }
      totalEntropy += Math.log2(2); // Entropy for choosing separator (none or space)
      return Math.round(totalEntropy);
    }

    function formatTimeToCrack(seconds) {
      if (seconds < 1) return "< 1 second";
      if (seconds < 60) return `${Math.round(seconds)} seconds`;
      const minutes = seconds / 60;
      if (minutes < 60) return `${Math.round(minutes)} minutes`;
      const hours = minutes / 60;
      if (hours < 24) return `${Math.round(hours)} hours`;
      const days = hours / 24;
      if (days < 365) return `${Math.round(days)} days`;
      const years = days / 365;
      if (years < 1000) return `${Math.round(years)} years`;
      if (years < 1e6) return `${Math.round(years / 1000)}k years`;
      if (years < 1e9) return `${Math.round(years / 1e6)}M years`;
      return `${(years / 1e9).toFixed(1)}B years`;
    }

    function updateStrengthMeter(entropy) {
      const strengthBar = document.getElementById("strengthBar");
      const strengthText = document.getElementById("strengthText");
      const guessesPerSecond = 339e9; // Approximate 339 GH/s for RTX 5090, based on 33% boost over RTX 4090's 255 GH/s
      const secondsToCrack = Math.pow(2, entropy) / guessesPerSecond;
      const timeToCrack = formatTimeToCrack(secondsToCrack);
      
      let width = "100%"; // Always fill the bar, adjust color based on difficulty
      let color = "#ff0000"; // Red for easiest (less than 1 second)

      if (secondsToCrack >= 365 * 24 * 3600 * 100) { // 100 years
        color = "#00ff99"; // Green for hardest
      } else if (secondsToCrack >= 24 * 3600 * 30) { // 30 days
        color = "#00ccff"; // Cyan for moderately hard
      } else if (secondsToCrack >= 3600) { // 1 hour
        color = "#ffaa00"; // Orange for somewhat hard
      } else if (secondsToCrack >= 1) { // 1 second
        color = "#ff5555"; // Lighter red for slightly harder
      }

      strengthBar.style.width = width;
      strengthBar.style.background = color;
      strengthText.textContent = `Time to crack with RTX 5090: ${timeToCrack}`;
    }

    function updateMFASecurityMeter(entropy) {
      const mfaSecurityBar = document.getElementById("mfaSecurityBar");
      const mfaSecurityText = document.getElementById("mfaSecurityText");
      const addSpaces = document.getElementById("addSpaces").checked; // Assuming MFA is tied to the "Add Spaces" checkbox as a proxy
      let likelihood = "Possible";
      let width = "25%";
      let color = "#ff0048";

      if (addSpaces) { // If MFA is enabled
        if (entropy >= 30) { // Extremely Unlikely: ≥1 year + MFA
          likelihood = "Extremely Unlikely";
          width = "100%";
          color = "#00ff99";
        } else if (entropy >= 25) { // Very Unlikely: ≥1 day + MFA
          likelihood = "Very Unlikely";
          width = "75%";
          color = "#00ccff";
        } else { // Unlikely: <1 day + MFA (minimum when MFA is enabled)
          likelihood = "Unlikely";
          width = "85%"; // Adjusted to 85% for minimum MFA protection
          color = "#ffaa00";
        }
      } else if (entropy >= 30) { // Extremely Unlikely without MFA
        likelihood = "Extremely Unlikely";
        width = "100%";
        color = "#00ff99";
      } else if (entropy >= 25) { // Very Unlikely without MFA
        likelihood = "Very Unlikely";
        width = "75%";
        color = "#00ccff";
      } else if (entropy >= 20) { // Unlikely without MFA
        likelihood = "Unlikely";
        width = "50%";
        color = "#ffaa00";
      } else { // Possible without MFA
        likelihood = "Possible";
        width = "25%";
        color = "#ff0048";
      }

      mfaSecurityBar.style.width = width;
      mfaSecurityBar.style.background = color;
      mfaSecurityText.textContent = `Cracking Likelihood with MFA: ${likelihood}`;
    }

    function copyToClipboard() {
      const passphraseElement = document.getElementById("passphrase");
      const passphrase = passphraseElement.textContent;
      const copyMessage = document.getElementById("copyMessage");

      if (passphrase === "Click below to generate") {
        copyMessage.textContent = "Please generate a password first!";
        copyMessage.classList.add("show");
        setTimeout(() => copyMessage.classList.remove("show"), 3000);
        return;
      }

      if (window.isSecureContext && navigator.clipboard) {
        navigator.clipboard.writeText(passphrase).then(() => {
          copyMessage.textContent = "Password copied to clipboard!";
          copyMessage.classList.add("show");
          setTimeout(() => copyMessage.classList.remove("show"), 3000);
        }).catch(() => {
          copyMessage.textContent = "Clipboard access blocked. Password selected; press Ctrl+C (or Cmd+C) to copy.";
          copyMessage.classList.add("show");
          const range = document.createRange();
          range.selectNodeContents(passphraseElement);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
          setTimeout(() => copyMessage.classList.remove("show"), 3000);
        });
      } else {
        copyMessage.textContent = "Clipboard access unavailable. Password selected; press Ctrl+C (or Cmd+C) to copy.";
        copyMessage.classList.add("show");
        const range = document.createRange();
        range.selectNodeContents(passphraseElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        setTimeout(() => copyMessage.classList.remove("show"), 3000);
      }
    }

    function generatePassphrase() {
      let wordCount = parseInt(document.getElementById("wordCount").value);
      const specialCharCount = parseInt(document.getElementById("specialCharCount").value);
      const leetCount = parseInt(document.getElementById("leetCount").value);
      const caseStyle = document.getElementById("caseStyle").value;
      const addSpaces = document.getElementById("addSpaces").checked;
      let words = [];
      let leetWordIndices = [];
      let leetCharCount = 0;
      let specialApplied = [];
      let leetApplied = [];
      let passphrase;

      do {
        words = [];
        leetCharCount = 0;
        leetWordIndices = [];
        specialApplied = [];
        leetApplied = [];

        // Select words
        for (let i = 0; i < wordCount; i++) {
          const word = baseWords[Math.floor(Math.random() * baseWords.length)].toLowerCase();
          words.push(word);
          for (let char of word) {
            if (leetMap[char]) leetCharCount++;
          }
        }

        // Apply leetspeak only if leetCount > 0
        if (leetCount > 0) {
          const wordIndices = Array.from({length: wordCount}, (_, i) => i);
          const eligibleLeetIndices = wordIndices.filter(i => words[i].split('').some(c => leetMap[c]));
          for (let i = 0; i < Math.min(leetCount, wordCount); i++) {
            if (eligibleLeetIndices.length > 0) {
              const index = eligibleLeetIndices.splice(Math.floor(Math.random() * eligibleLeetIndices.length), 1)[0];
              leetWordIndices.push(index);
            } else {
              break; // No more eligible words
            }
          }
          while (leetWordIndices.length < leetCount && baseWords.some(w => w.split('').some(c => leetMap[c]))) {
            const newWord = baseWords.filter(w => w.split('').some(c => leetMap[c]))[Math.floor(Math.random() * baseWords.length)].toLowerCase();
            words.push(newWord);
            wordCount++;
            const newIndex = wordCount - 1;
            leetWordIndices.push(newIndex);
            for (let char of newWord) {
              if (leetMap[char]) leetCharCount++;
            }
          }
          const modifiedWords = words.map((word, index) => {
            const wordLeetApplied = [];
            let modifiedWord = toLeetspeak(word, wordLeetApplied, leetWordIndices.includes(index), index);
            leetApplied.push(...wordLeetApplied);
            return modifiedWord;
          });
          words = modifiedWords;
        }

        // Apply special characters only if specialCharCount > 0
        if (specialCharCount > 0) {
          const positions = Array.from({length: wordCount + 1}, (_, i) => i);
          for (let i = 0; i < specialCharCount; i++) {
            if (positions.length > 0) {
              const posIndex = positions.splice(Math.floor(Math.random() * positions.length), 1)[0];
              const special = specialChars[Math.floor(Math.random() * specialChars.length)];
              specialApplied.push({ pos: posIndex, char: special });
            } else {
              let posIndex;
              let attempt = 0;
              do {
                posIndex = Math.floor(Math.random() * (wordCount + 1));
                attempt++;
              } while (specialApplied.some(sa => sa.pos === posIndex) && attempt < 10);
              const special = specialChars[Math.floor(Math.random() * specialChars.length)];
              specialApplied.push({ pos: posIndex, char: special });
            }
          }
          specialApplied.sort((a, b) => a.pos - b.pos);
        }

        passphrase = applyCaseStyle(words, caseStyle, leetApplied, specialApplied, addSpaces);
      } while ((specialCharCount > 0 && !passphrase.match(new RegExp(`[${specialChars.join('')}]`))) || passphrase.length < 14 || (specialCharCount > 0 && specialApplied.length !== specialCharCount) || (leetCount > 0 && leetApplied.length !== leetCount));

      let totalLetters = 0;
      for (let i = 0; i < passphrase.length; i++) {
        if (/[a-zA-Z]/.test(passphrase[i])) totalLetters++;
      }

      const entropy = estimateEntropy(words, leetWordIndices, leetCharCount, specialCharCount, caseStyle, totalLetters, addSpaces);
      document.getElementById("passphrase").textContent = passphrase;
      document.getElementById("entropy").textContent = `Entropy: ${entropy} bits`;
      document.getElementById("charCount").textContent = `Length: ${passphrase.length} characters`;
      updateStrengthMeter(entropy);
      updateMFASecurityMeter(entropy);
    }

    document.addEventListener('DOMContentLoaded', () => {
      const select = document.getElementById("wordCount");
      const options = select.options;
      const minWords = 3;
      for (let i = 0; i < options.length; i++) {
        if (parseInt(options[i].value) < minWords) {
          options[i].disabled = true;
        }
      }
    });
  </script>
</body>
</html>